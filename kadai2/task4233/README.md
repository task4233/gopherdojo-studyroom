# io.Readerとio.Writerの調査
## 標準パッケージでどのように使われているかを調査する
### ioパッケージとは
- ioパッケージは、I/Oプリミティブへの基本インタフェースを提供する
- その主な仕事は、osパッケージのような、機能を抽象化した共有のpublicなインタフェースに既存のプリミティブの実装をラップし、他の関連するプリミティブを提供すること
- これらのインタフェースやプリミティブは低レベルな命令を様々な実装でラップするため、クライアントは特に知らされてない限り、平行実行にとって安全であると想定すべきではない
- ref: [package io overview](https://golang.org/pkg/io/#pkg-overview)

### io.Readerとは
Readerは基本的なReadメソッドをラップするインタをフェース
Readはpに含まれる`len(p)`バイトを読み上げる。それは、読んだバイト数(`0 <= n <= len(p)`)と発生した何らかのエラーを返す。たとえ、Readが`n < len(p)‘を返したとしても、呼ばれている間スクラッチスペースとしてpのすべてを用いているかもしれない。もし、`len(p)`バイトではない何らかのデータが利用可能なら、Readは従来通りそれ以上待つ代わりに可能なものを返す。

Readが、n>0バイトの読み取りに成功した後に、エラーかファイルの終端に来た時、読んだバイト数を返す。もし、nilでないエラーが同じ呼び出しを返すか、次の

ref: [package io Reader](https://golang.org/pkg/io/#Reader)

```golang
type Reader interface {
    Read(p []byte) (n int, err error)
}
```

io.Readerを実装するには、`Read([]byte) (int, error)`を実装すれば良いです。

### osパッケージでの実装例

## io.Readerとio.Writerがあることによって得られる利点を具体例を挙げて考える

# テストを書いてみよう
 - テストのしやすさを考えてリファクタリングする
 - テストのカバレッジを取る
 - テーブル駆動テストを行う
 - テストヘルパーを作る
